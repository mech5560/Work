/*Last Modified Time-stamp: <2014-04-24 16:45:18 mike_georgiou>*/

/*Definition of the libraries that this program will use*/
#include "./Header_Files/Struct.h"
#include "./Header_Files/Variables.h"
#include "./Header_Files/Data.h"
#include "./Header_Files/Macros.h"
#include "./Header_Files/Matrix_Alloc_New.h"
#include "./Header_Files/Matrix_Alloc.h"
#include "./Header_Files/Functions.h"
#include "./Header_Files/Libraries.h"

using namespace std;

int main (int argc, char *argv[]){

	char *file;
	file = new char[100];

  //Defining the number of solution points in each direction
  Nx=50; Ny=50; Nz=50;
  ldx=Nx; ldy=Ny; ldz=Nz;

  //Defining the Non-Zero Elements for the Poisson solver
  Nze = 15*ldz*(ldy-2)*ldx + 14*ldz*ldx*2;
  Dim_A=ldz*ldy*ldx; //Dimension of the A matrix of the Poisson Equation

  //Defining the extra points on each direction depending on the BC
  lx=3; rx=3;
  lz=3; rz=3;
  ly=1; ry=1;

  Allocator(&Arr,ldz,ldy,ldx,
						lz,rz,
						ly,ry,
						lx,rx);

  //Vectors for the Poisson Solver
  s_A = new double [Nze  +2];
  Alloc_Check(s_A);

  ij_A = new int [Nze  +2];
  Alloc_Check(ij_A);

  RHS = new double [Dim_A +1];
  Alloc_Check(RHS);

  Precond_A = new double [Dim_A +1];
  Alloc_Check(Precond_A);

  Result = new double [Dim_A +1];
  Alloc_Check(Result);


  //Defining the Dy's of my code - At this moment I have a uniform grid but
	//the code can be adopt non-uniform grid
  Cubic_Mesh(Arr.Delta_Y,ldz,  ldy, ldx,lz,rz,ly,ry,lx,rx);


  /*Calculating dx and dz*/
  dx= 1./(ldx*1.0);
  dz= 1./(ldz*1.0);

  // Defining the Second derivative coefficients  that will be use by the
  // Vector_Constructor Function
  
	Coefficients_X[0] = 1./(576.*dx*dx);
  Coefficients_X[1] = -9./(96.*dx*dx);
  Coefficients_X[2] = ( 81./(64.*dx*dx) + 9./(96.*dx*dx) );
  Coefficients_X[3] = (- 81./(32.*dx*dx) - 1./(288.*dx*dx) );

  Coefficients_Z[0] = 1./(576.*dz*dz);
  Coefficients_Z[1] = -9./(96.*dz*dz);
  Coefficients_Z[2] = ( 81./(64.*dz*dz) + 9./(96.*dz*dz) );
  Coefficients_Z[3] = (- 81./(32.*dz*dz) - 1./(288.*dz*dz) );

  /////////////////////////////////////////////////////////////
	//////////////////Initial Conditions/////////////////////////
	/////////////////////////////////////////////////////////////

  //Assigning zero Initial conditions for the velocities and Arr.Temperature

  //Initializing the Velocities
  Initial_Zero(Arr.Speed_X, ldz, ldy, ldx,lz,rz,ly,ry,lx,rx);
  Initial_Zero(Arr.Speed_Y, ldz, ldy, ldx,lz,rz,ly,ry,lx,rx);
  Initial_Zero(Arr.Speed_Z, ldz, ldy, ldx,lz,rz,ly,ry,lx,rx);


  //Initializing the Arr.Temperature
  Initial_One(Arr.Temperature, ldz, ldy, ldx,lz,rz,ly,ry,lx,rx);
  BC_Single(Arr.Temperature, ldz, ldy, ldx,
            lz, rz,
            ly, ry,
            lx, rx,1,
            Temp_Top, Temp_Bottom,Arr.Delta_Y);


  //Initializing  the Density for each Point
  Density_Calculator(Arr.Rho_Nm1, Arr.Temperature, ldz, ldy, ldx);
  BC_Single(Arr.Rho_Nm1, ldz, ldy, ldx,
            lz, rz,
            ly, ry,
            lx, rx,0,
            Rho_Grad_Top, Rho_Grad_Bottom,Arr.Delta_Y);


	Density_Calculator(Arr.Rho, Arr.Temperature, ldz, ldy, ldx);
  BC_Single(Arr.Rho, ldz, ldy, ldx,
            lz, rz,
            ly, ry,
            lx, rx,0,
            Rho_Grad_Top, Rho_Grad_Bottom,Arr.Delta_Y);


  /*Implementing the Velocity  boundary conditions for the predictor stage*/
  BC_Predictor( &Arr, ldz,ldy,ldx,
                lz,rz,
                ly,ry,
                lx,rx,0);

  /*Initializing the Arr.Fluxes.
    In order to do that I will use the Arr.Flux_Evaluation function.
    But with the initial values as an input*/

  Flux_Evaluation_X(Arr.Flux_X, Arr.Speed_X,
                    Arr.Rho_Nm1, Arr.Pressure,
                    dx, ldz,  ldy,  ldx+1);

  Flux_Evaluation_Y(Arr.Flux_Y, Arr.Speed_Y,
                    Arr.Rho_Nm1, Arr.Pressure,
                    Arr.Delta_Y, ldz,  ldy+1, ldx);

  Flux_Evaluation_Z(Arr.Flux_Z, Arr.Speed_Z,
                    Arr.Rho_Nm1,  Arr.Pressure,
                    dz, ldz+1,  ldy,  ldx);

  /*Assigning the BC for the Fluxes and the Intermediate Velocities*/
  BC_Flux(Arr.Flux_Z,Arr.Flux_Y,Arr.Flux_X,
          Arr.Speed_Int_Z, Arr.Speed_Int_Y, Arr.Speed_Int_X,
          ldz,ldy,ldx,
          lz,rz,
          ly,ry,
          lx,rx);


  /*Initializing the Arr.Residuals at the n-1 time
    In order to do that I will use the Velosity Residual Functions.
    but with the initial values velocities as an input*/

  Velocity_Residual_X( Arr.Residual_Old_X, Arr.Speed_Z, Arr.Speed_Y,
                       Arr.Speed_X, Arr.Delta_Y,    Arr.Flux_Z,
                       Arr.Flux_Y,  Arr.Flux_X,  Arr.Temperature,
                       dz,  dx,  ldz,  ldy,  ldx);

  Velocity_Residual_Y( Arr.Residual_Old_Y,  Arr.Speed_Z,  Arr.Speed_Y,
											 Arr.Speed_X, Arr.Delta_Y,    Arr.Flux_Z,
											 Arr.Flux_Y,  Arr.Flux_X,Arr.Temperature,
											 dz,  dx,  ldz,  ldy,  ldx);

  Velocity_Residual_Z( Arr.Residual_Old_Z,  Arr.Speed_Z,  Arr.Speed_Y,
											 Arr.Speed_X, Arr.Delta_Y,   Arr.Flux_Z,
											 Arr.Flux_Y,  Arr.Flux_X, Arr.Temperature,
											 dz,  dx, ldz,  ldy,  ldx);



  /*Before Entering the time integration loop
    i will define the constant vectors for the poisson solver*/
  Vector_Constructor(s_A, Precond_A, ij_A,
                     Coefficients_Z,  Coefficients_X, Arr.Delta_Y,
                     ldz,  ldy,  ldx,  Nze);

  //////////////////////////////////////////////////////////////////////
  //////////////////////Time Integration Loop///////////////////////////
  //////////////////////////////////////////////////////////////////////

   for (int time_index=0; time_index<1e5; time_index++ )
    {
			
      //////////////////////////////////////////////////////////////////////
      ///////////////////////////// Predictor Stage ////////////////////////
      //////////////////////////////////////////////////////////////////////

      BC_Predictor( &Arr, ldz,ldy,ldx,
                    lz,rz,
                    ly,ry,
                    lx,rx,0);


      /*Calculating the Arr.Temperature at the Predictor stage*/
      Energy_Equation(Arr.Temperature_New, Arr.Temperature, Arr.Rho,
											Arr.Speed_Z,Arr.Speed_Y, Arr.Speed_X,
											Arr.Delta_Y, dz, dx, ldz, ldy, ldx);

      BC_Single(Arr.Temperature_New, ldz,ldy,ldx,lz,rz,ly,ry,lx,rx,1,
                Temp_Top,Temp_Bottom,Arr.Delta_Y);


      /*Computing Arr.Rho_Star*/
      Density_Calculator(Arr.Rho_New, Arr.Temperature_New, ldz, ldy, ldx);
      BC_Single(Arr.Rho_New, ldz,ldy,ldx,lz,rz,ly,ry,lx,rx,0,
                Rho_Grad_Top,Rho_Grad_Bottom,Arr.Delta_Y);



      /*Calculating the Intermediate Velocity at the Predictor stage*/
      Intermediate_Velocity_X(Arr.Speed_Int_X,  Arr.Residual_X,
                              Arr.Residual_Old_X, Arr.Speed_Z, Arr.Speed_Y,
                              Arr.Speed_X,  Arr.Flux_Z, Arr.Flux_Y,
                              Arr.Flux_X, Arr.Delta_Y,  Arr.Rho_New, Arr.Rho,
															Arr.Temperature_New,
                              dz,  dx, ldz,  ldy,  ldx);

      Intermediate_Velocity_Y(Arr.Speed_Int_Y,  Arr.Residual_Y,
                              Arr.Residual_Old_Y, Arr.Speed_Z, Arr.Speed_Y,
                              Arr.Speed_X,  Arr.Flux_Z, Arr.Flux_Y,
                              Arr.Flux_X, Arr.Delta_Y,  Arr.Rho_New, Arr.Rho,
                              Arr.Temperature_New,
                              dz,  dx, ldz,  ldy,  ldx);

      Intermediate_Velocity_Z(Arr.Speed_Int_Z,  Arr.Residual_Z,
                              Arr.Residual_Old_Z, Arr.Speed_Z, Arr.Speed_Y,
                              Arr.Speed_X,  Arr.Flux_Z, Arr.Flux_Y,
                              Arr.Flux_X, Arr.Delta_Y,  Arr.Rho_New, Arr.Rho,
                              Arr.Temperature_New,
                              dz,  dx, ldz,  ldy,  ldx);


			// file="tildap";
			// Print_3D_File(Arr.Speed_Int_Y,ldz,ldy,ldx, time_index, file);

      BC_Flux(Arr.Flux_Z,Arr.Flux_Y,Arr.Flux_X,
              Arr.Speed_Int_Z, Arr.Speed_Int_Y, Arr.Speed_Int_X,
              ldz,ldy,ldx,
              lz,rz,
              ly,ry,
              lx,rx);


      /*Solving the Poisson Equation
        To do that, I will use the bcgs-solver of Christos.
        The s_A ij_A and Precond_A vectors will be constructed once and
        they will be defined outside the iterating part of the code*/


      //Determining the RHS of the Poisson Equation
      RHS_Poisson(RHS,Arr.Speed_Int_X,
                  Arr.Speed_Int_Y, Arr.Speed_Int_Z,
                  Arr.Rho_New,Arr.Rho, Arr.Rho_Nm1, Arr.Delta_Y,
                  dz,  dx, ldz,  ldy,  ldx);

			// file = "rhsp";
			// Print_3D_Single(RHS,ldz,ldy,ldx,time_index,file);
			

      /*solving the Poisson Equation*/
      BCSG_Printing(s_A, ij_A, Result, RHS, Precond_A,
					 1e-15, 3000, Dim_A, flag);
      if(flag==1)
        {
          cout<<time_index<<endl;
          break;
				}

      /*Passing the Poisson solution to the Arr.Pressure_New Array*/
      for (int k=0; k<ldz; k++)
        {
          for (int j=0; j<ldy; j++)
            {
              for (int i=0; i<ldx; i++)
                {
                  Arr.Pressure_New[k][j][i] = Result[A(k,j,i) +1];
                }
            }
        }

			// file="pressurep"; 
			// Print_3D_File(Arr.Pressure_New, ldz, ldy, ldx, time_index, file);

			
      BC_Single(Arr.Pressure_New, ldz,ldy,ldx,lz,rz,ly,ry,lx,rx,0,
                Press_Grad_Top, Press_Grad_Bottom, Arr.Delta_Y);


      /*computing the Updated Velocity*/
      Velocity_Update_X(Arr.Speed_New_X, Arr.Speed_Int_X,
                        Arr.Rho_New, Arr.Pressure_New,
                        dx, ldz,  ldy,  ldx);

      Velocity_Update_Z(Arr.Speed_New_Z,  Arr.Speed_Int_Z,
                        Arr.Rho_New, Arr.Pressure_New,
                        dz, ldz,  ldy,  ldx);

      Velocity_Update_Y(Arr.Speed_New_Y,  Arr.Speed_Int_Y,
                        Arr.Rho_New, Arr.Pressure_New,
                        Arr.Delta_Y, ldz,  ldy,  ldx);

			// file="up";
			// Print_3D_File(Arr.Speed_X,ldz,ldy,ldx, time_index, file);
			// file="wp";
			// Print_3D_File(Arr.Speed_Z,ldz,ldy,ldx, time_index, file);
			// file="vp";
			// Print_3D_File(Arr.Speed_Y,ldz,ldy,ldx, time_index, file);
	

      BC_Corrector( &Arr, ldz,ldy,ldx,
                    lz,rz,
                    ly,ry,
                    lx,rx,0);


      /*Updating the Auxiliary Arr.Fluxes in order to proceed at
        the Corrector Stage
      */
      Flux_Evaluation_X(Arr.Flux_X, Arr.Speed_Int_X,
                        Arr.Rho_New, Arr.Pressure_New,
                        dx, ldz,  ldy,  ldx+1);


      Flux_Evaluation_Y(Arr.Flux_Y, Arr.Speed_Int_Y,
                        Arr.Rho_New, Arr.Pressure_New,
                        Arr.Delta_Y, ldz,  ldy+1,  ldx);


      Flux_Evaluation_Z(Arr.Flux_Z, Arr.Speed_Int_Z,
                        Arr.Rho_New,  Arr.Pressure_New,
                        dx, ldz+1,  ldy,  ldx);



      /*Applying the Boundary conditions to the computed fluxes*/
      BC_Flux(Arr.Flux_Z,Arr.Flux_Y,Arr.Flux_X,
              Arr.Speed_Int_Z, Arr.Speed_Int_Y, Arr.Speed_Int_X,
              ldz,ldy,ldx,
              lz,rz,
              ly,ry,
              lx,rx);
			
			// file="fluxyp";
			// Print_3D_File(Arr.Flux_Y,ldz,ldy+1,ldx, time_index, file);

			// file="fluxxp";
			// Print_3D_File(Arr.Flux_X,ldz,ldy+1,ldx, time_index, file);


			// file="fluxzp";
			// Print_3D_File(Arr.Flux_Z,ldz,ldy+1,ldx, time_index, file);

			// getchar();

      /////////////////////////////////////////////////////////////
      ////////////////// end of the Predictor Stage ///////////////
      /////////////////////////////////////////////////////////////



      /////////////////////////////////////////////////////////////
      ////////////////// Corrector Stage //////////////////////////
      /////////////////////////////////////////////////////////////

      /*Calculating the Arr.Temperature_Av which is necessary for the calculation of the temperature
        at the corrector stage*/
      for (int k=0; k<ldz; k++)
        {
          for (int j = 0; j < ldy; j++)
            {
              for (int i=0; i<ldx; i++)
                {
                  Arr.Temperature_Av[k][j][i]=0.5*
                    (Arr.Temperature[k][j][i] + Arr.Temperature_New[k][j][i]);
                }
            }
        }


      BC_Single(Arr.Temperature_Av, ldz,ldy,ldx,lz,rz,ly,ry,lx,rx,1,
                Temp_Top, Temp_Bottom, Arr.Delta_Y);


      /*Calculating the Arr.Temperature at the Predictor stage*/
      Temperature_Update_Corrector(Arr.Temperature_New,Arr.Temperature_Av,
                                   Arr.Temperature, Arr.Rho_New, Arr.Speed_New_Z, Arr.Speed_New_Y,
                                   Arr.Speed_New_X,Arr.Delta_Y, dz,  dx,ldz,  ldy,   ldx);

      BC_Single(Arr.Temperature_New, ldz,ldy,ldx,lz,rz,ly,ry,lx,rx,1,
                Temp_Top, Temp_Bottom, Arr.Delta_Y);



      /*Computing Arr.Rho_Star*/
      Density_Calculator(Arr.Rho_New, Arr.Temperature_New, ldz, ldy, ldx);
      BC_Single(Arr.Rho_New, ldz, ldy, ldx,
                lz, rz,
                ly, ry,
                lx, rx,0,
                Rho_Grad_Top, Rho_Grad_Bottom,Arr.Delta_Y);


      /*Determining the RHS of the Poisson Equation*/
      RHS_Poisson( RHS, Arr.Speed_Int_X,
                   Arr.Speed_Int_Y, Arr.Speed_Int_Z,
                   Arr.Rho_New,Arr.Rho, Arr.Rho_Nm1, Arr.Delta_Y,
                   dz,  dx, ldz,  ldy,  ldx);

			// file = "rhsc";
			// Print_3D_Single(RHS,ldz,ldy,ldx,time_index,file);


      /*Solving the Poisson Equation*/
      BCSG_Printing(s_A, ij_A, Result, RHS, Precond_A,
					 1e-15,3000,Dim_A,flag);
      if(flag==1)
        {
          cout<<time_index<<endl;
          break;
        }

      /*Passing the Poisson solution to the Arr.Pressure_New Array*/
      for (int k=0; k<ldz; k++)
        {
          for (int j=0; j<ldy; j++)
            {
              for (int i=0; i<ldx; i++)
                {
                  Arr.Pressure_New[k][j][i] = Result[A(k,j,i) +1];
                }
            }
        }
			// file="pressurec";
			// 	Print_3D_File(Arr.Pressure_New, ldz, ldy, ldx, time_index, file);
			// 	//return 0;


      BC_Single(Arr.Pressure_New, ldz,ldy,ldx,lz,rz,ly,ry,lx,rx,0,
                Press_Grad_Top, Press_Grad_Bottom, Arr.Delta_Y);


      /*computing the Updated Velocity*/
      Velocity_Update_X(Arr.Speed_New_X, Arr.Speed_Int_X,
                        Arr.Rho_New, Arr.Pressure_New,
                        dx, ldz,  ldy,  ldx);


      Velocity_Update_Y(Arr.Speed_New_Y,  Arr.Speed_Int_Y,
                        Arr.Rho_New, Arr.Pressure_New,
                        Arr.Delta_Y, ldz,  ldy,  ldx);

      Velocity_Update_Z(Arr.Speed_New_Z,  Arr.Speed_Int_Z,
                        Arr.Rho_New, Arr.Pressure_New,
                        dz, ldz,  ldy,  ldx);


			// file="vc";
			// Print_3D_File(Arr.Speed_Y,ldz,ldy,ldx, time_index, file);

			// file="uc";
			// Print_3D_File(Arr.Speed_X,ldz,ldy,ldx, time_index, file);
			// file="wc";
			// Print_3D_File(Arr.Speed_Z,ldz,ldy,ldx, time_index, file);


      /*Updating the Auxiliary Arr.Fluxes in order to proceed at
        the next timestep
      */

      Flux_Evaluation_X(Arr.Flux_X, Arr.Speed_Int_X,
                        Arr.Rho_New, Arr.Pressure_New,
                        dx, ldz,  ldy,  ldx+1);


      Flux_Evaluation_Y(Arr.Flux_Y, Arr.Speed_Int_Y,
                        Arr.Rho_New, Arr.Pressure_New,
                        Arr.Delta_Y, ldz,  ldy+1,  ldx);


      Flux_Evaluation_Z(Arr.Flux_Z, Arr.Speed_Int_Z,
                        Arr.Rho_New,  Arr.Pressure_New,
                        dx, ldz+1,  ldy,  ldx);


	// file="fluxyc";
	// Print_3D_File(Arr.Flux_Y,ldz,ldy+1,ldx, 0, file);

	// file="fluxxc";
	// Print_3D_File(Arr.Flux_X,ldz,ldy+1,ldx, 0, file);

	// file="fluxzc";
	// Print_3D_File(Arr.Flux_Z,ldz,ldy+1,ldx, 0, file);


      ////////////////////////////////////////////////////////////////
      ////////////////End of the Corrector Stage /////////////////////
      ///////////////////////////////////////////////////////////////

      char X[]="X_";
      char Y[]="Y_";
      char Z[]="Z_";


      if (time_index%200==0)
        {
          Print_3D_File (Arr.Speed_New_X,ldz,ldy,ldx,time_index,X);
          Print_3D_File (Arr.Speed_New_Y,ldz,ldy,ldx,time_index,Y);
          Print_3D_File(Arr.Speed_New_Z,ldz,ldy,ldx,time_index,Z);
          cout<<time_index<<endl;
        }


      /*Passing the data to proceed  to the next time step*/
      Temp=Arr.Speed_X;
      Arr.Speed_X= Arr.Speed_New_X;
      Arr.Speed_New_X = Temp;

      Temp=Arr.Speed_Y;
      Arr.Speed_Y= Arr.Speed_New_Y;
      Arr.Speed_New_Y = Temp;

      Temp=Arr.Speed_Z;
      Arr.Speed_Z= Arr.Speed_New_Z;
      Arr.Speed_New_Z = Temp;

      Temp=Arr.Temperature;
      Arr.Temperature = Arr.Temperature_New;
      Arr.Temperature_New = Temp;

      Temp = Arr.Rho_Nm1;
      Arr.Rho_Nm1 = Arr.Rho;
      Arr.Rho = Temp;

      Temp = Arr.Rho;
      Arr.Rho = Arr.Rho_New;
      Arr.Rho_New = Temp;

      Temp = Arr.Residual_Old_X;
      Arr.Residual_Old_X = Arr.Residual_X;
      Arr.Residual_X = Temp;

      Temp = Arr.Residual_Old_Y;
      Arr.Residual_Old_Y = Arr.Residual_Y;
      Arr.Residual_Y = Temp;

      Temp = Arr.Residual_Old_Z;
      Arr.Residual_Old_Z = Arr.Residual_Z;
      Arr.Residual_Z = Temp;

      Temp = Arr.Pressure;
      Arr.Pressure=Arr.Pressure_New;
      Arr.Pressure_New = Temp;
				}

  /*Releasing the allocated memory*/

  DeAllocator(  &Arr,  ldz,  ldy,  ldx,
                lz,  rz,  ly,  ry,  lx,  rx);

  delete[] s_A;
  delete[] ij_A;
  delete[] Precond_A;
  delete[] RHS;
  delete[] Result;
	delete [] file;
		}

